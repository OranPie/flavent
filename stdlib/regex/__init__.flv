use std.option
use std.result
use _bridge_python
use collections.list

// Minimal regex surface for now.
//
// Future directions:
// - Return Result[Regex, Str] from compile() (syntax validation).
// - Implement NFA/DFA in pure Flavent.
// - Or route execution through an internal bridge (discouraged unless unavoidable).

type Regex = { pat: Str }

type RxSpan = { start: Int, end: Int }

fn regex(pat: Str) -> Regex = { pat = pat }

// Alias for now.
fn compile(pat: Str) -> Regex = regex(pat)

fn _rxValidate(pat: Str, i: Int, end: Int, depth: Int) -> Result[Unit, Str] = match i >= end:
  true -> match depth == 0:
    true -> Ok(())
    false -> Err("unterminated group")
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92:
      true -> match i + 1 < end:
        true -> _rxValidate(pat, i + 2, end, depth)
        false -> Err("dangling escape")
      false -> match c == 91:
        true -> do:
          let j = _rxFindClassEnd(pat, i + 1, end)
          return match j < 0:
            true -> Err("unterminated class")
            false -> _rxValidate(pat, j + 1, end, depth)
        false -> match c == 40:
          true -> _rxValidate(pat, i + 1, end, depth + 1)
          false -> match c == 41:
            true -> match depth <= 0:
              true -> Err("unmatched )")
              false -> _rxValidate(pat, i + 1, end, depth - 1)
            false -> _rxValidate(pat, i + 1, end, depth)

fn compileChecked(pat: Str) -> Result[Regex, Str] = do:
  let v = _rxValidate(pat, 0, _rxLen(pat), 0)
  return match v:
    Err(e) -> Err(e)
    Ok(_) -> Ok(regex(pat))

type _RxRange = { lo: Int, hi: Int }

type _RxClass = { invert: Bool, ranges: List[_RxRange], digit: Bool, word: Bool, space: Bool }

type _RxAtom = RxAny(Int) | RxChar(Int, Int) | RxClass(_RxClass, Int) | RxBoundary(Int)

type RxCapture = { idx: Int, start: Int, end: Int }

type _RxCapRes = { end: Int, caps: List[RxCapture] }

fn _rxCodeAt(s: Str, i: Int) -> Int = strCodeAt(s, i)

fn _rxLen(s: Str) -> Int = strLen(s)

fn _rxChar(code: Int) -> Str = strFromCode(code)

fn _rxIsDigit(c: Int) -> Bool = c >= 48 and c <= 57

fn _rxIsUpper(c: Int) -> Bool = c >= 65 and c <= 90

fn _rxIsLower(c: Int) -> Bool = c >= 97 and c <= 122

fn _rxIsWord(c: Int) -> Bool = _rxIsUpper(c) or _rxIsLower(c) or _rxIsDigit(c) or c == 95

fn _rxIsSpace(c: Int) -> Bool = c == 32 or c == 9 or c == 10 or c == 13

fn _rxIsWordAt(s: Str, i: Int) -> Bool = match i < 0 or i >= _rxLen(s):
  true -> false
  false -> _rxIsWord(_rxCodeAt(s, i))

fn _rxIsBoundary(s: Str, si: Int) -> Bool = do:
  let left = _rxIsWordAt(s, si - 1)
  let right = _rxIsWordAt(s, si)
  return left != right

fn _rxRangeMatches(r: _RxRange, c: Int) -> Bool = c >= r.lo and c <= r.hi

fn _rxRangesMatches(rs: List[_RxRange], c: Int) -> Bool = match rs:
  Nil -> false
  Cons(r, rest) -> match _rxRangeMatches(r, c):
    true -> true
    false -> _rxRangesMatches(rest, c)

fn _rxClassMatches(cls: _RxClass, c: Int) -> Bool = do:
  let m0 = _rxRangesMatches(cls.ranges, c)
  let m1 = cls.digit and _rxIsDigit(c)
  let m2 = cls.word and _rxIsWord(c)
  let m3 = cls.space and _rxIsSpace(c)
  let m = m0 or m1 or m2 or m3
  return match cls.invert:
    true -> not m
    false -> m

fn _rxHasAny[T](xs: List[T]) -> Bool = match xs:
  Nil -> false
  Cons(_x, _rest) -> true

fn _rxFindClassEnd(pat: Str, i: Int, end: Int) -> Int = match i >= end:
  true -> 0 - 1
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92 and i + 1 < end:
      true -> _rxFindClassEnd(pat, i + 2, end)
      false -> match c == 93:
        true -> i
        false -> _rxFindClassEnd(pat, i + 1, end)

fn _rxFindGroupClose(pat: Str, i: Int, end: Int, depth: Int) -> Int = match i >= end:
  true -> 0 - 1
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92 and i + 1 < end:
      true -> _rxFindGroupClose(pat, i + 2, end, depth)
      false -> match c == 91:
        true -> do:
          let j = _rxFindClassEnd(pat, i + 1, end)
          return match j < 0:
            true -> 0 - 1
            false -> _rxFindGroupClose(pat, j + 1, end, depth)
        false -> match c == 40:
          true -> _rxFindGroupClose(pat, i + 1, end, depth + 1)
          false -> match c == 41:
            true -> match depth == 1:
              true -> i
              false -> _rxFindGroupClose(pat, i + 1, end, depth - 1)
            false -> _rxFindGroupClose(pat, i + 1, end, depth)

fn _rxFindTopBar(pat: Str, i: Int, end: Int, depth: Int) -> Int = match i >= end:
  true -> 0 - 1
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92 and i + 1 < end:
      true -> _rxFindTopBar(pat, i + 2, end, depth)
      false -> match c == 91:
        true -> do:
          let j = _rxFindClassEnd(pat, i + 1, end)
          return match j < 0:
            true -> 0 - 1
            false -> _rxFindTopBar(pat, j + 1, end, depth)
        false -> match c == 40:
          true -> _rxFindTopBar(pat, i + 1, end, depth + 1)
          false -> match c == 41 and depth > 0:
            true -> _rxFindTopBar(pat, i + 1, end, depth - 1)
            false -> match c == 124 and depth == 0:
              true -> i
              false -> _rxFindTopBar(pat, i + 1, end, depth)

fn _rxAtomMatches(a: _RxAtom, s: Str, si: Int) -> Bool = match a:
  RxBoundary(_next) -> _rxIsBoundary(s, si)
  _ -> match si < _rxLen(s):
    false -> false
    true -> do:
      let c = _rxCodeAt(s, si)
      return match a:
        RxAny(_next) -> true
        RxChar(code, _next) -> c == code
        RxClass(cls, _next) -> _rxClassMatches(cls, c)
        RxBoundary(_next) -> _rxIsBoundary(s, si)

fn _rxAtomConsumes(a: _RxAtom) -> Bool = match a:
  RxBoundary(_next) -> false
  _ -> true

fn _rxConsumeLen(a: _RxAtom) -> Int = match _rxAtomConsumes(a):
  true -> 1
  false -> 0

fn _rxMatchEndsFromList(ends: List[Int], pat: Str, pi: Int, end: Int, s: Str) -> List[Int] = match ends:
  Nil -> Nil
  Cons(e, rest) -> append(_rxMatchEnds(pat, pi, end, s, e), _rxMatchEndsFromList(rest, pat, pi, end, s))

type _RxQuant = { kind: Int, next: Int, lazy: Bool }

fn _rxParseQuant(pat: Str, i: Int, end: Int) -> _RxQuant = do:
  return match i >= end:
    true -> { kind = 0, next = i, lazy = false }
    false -> do:
      let q = _rxCodeAt(pat, i)
      let isQuant = q == 42 or q == 43 or q == 63
      return match isQuant:
        false -> { kind = 0, next = i, lazy = false }
        true -> do:
          let isLazy = i + 1 < end and _rxCodeAt(pat, i + 1) == 63
          let next = match isLazy:
            true -> i + 2
            false -> i + 1
          return { kind = q, next = next, lazy = isLazy }

fn _rxMatchEndsStarGreedy(a: _RxAtom, pat: Str, pi: Int, end: Int, s: Str, si: Int) -> List[Int] = do:
  let base = _rxMatchEnds(pat, pi, end, s, si)
  return match _rxAtomMatches(a, s, si) and _rxAtomConsumes(a):
    true -> append(_rxMatchEndsStarGreedy(a, pat, pi, end, s, si + 1), base)
    false -> base

fn _rxMatchEndsStarLazy(a: _RxAtom, pat: Str, pi: Int, end: Int, s: Str, si: Int) -> List[Int] = do:
  let base = _rxMatchEnds(pat, pi, end, s, si)
  return match _rxAtomMatches(a, s, si) and _rxAtomConsumes(a):
    true -> append(base, _rxMatchEndsStarLazy(a, pat, pi, end, s, si + 1))
    false -> base

fn _rxMatchEndsGroupStar(pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, lazy: Bool) -> List[Int] = do:
  let inner = _rxMatchEnds(pat, pi + 1, close, s, si)
  let rec = _rxMatchEndsGroupStarFromList(inner, pat, pi, close, next, end, s, si, lazy)
  let base = _rxMatchEnds(pat, next, end, s, si)
  return match lazy:
    true -> append(base, rec)
    false -> append(rec, base)

fn _rxMatchEndsGroupStarFromList(ends: List[Int], pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, lazy: Bool) -> List[Int] = match ends:
  Nil -> Nil
  Cons(e, rest) -> do:
    let cur = match e == si:
      true -> Nil
      false -> _rxMatchEndsGroupStar(pat, pi, close, next, end, s, e, lazy)
    return append(cur, _rxMatchEndsGroupStarFromList(rest, pat, pi, close, next, end, s, si, lazy))

fn _rxMatchEndsGroupPlus(pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, lazy: Bool) -> List[Int] = do:
  let inner = _rxMatchEnds(pat, pi + 1, close, s, si)
  return _rxMatchEndsGroupStarFromList(inner, pat, pi, close, next, end, s, si, lazy)

fn _rxMatchEnds(pat: Str, pi: Int, end: Int, s: Str, si: Int) -> List[Int] = do:
  let slen = _rxLen(s)
  return match pi >= end:
    true -> Cons(si, Nil)
    false -> do:
      let bar = _rxFindTopBar(pat, pi, end, 0)
      return match bar >= 0:
        true -> append(_rxMatchEnds(pat, pi, bar, s, si), _rxMatchEnds(pat, bar + 1, end, s, si))
        false -> do:
          let c0 = _rxCodeAt(pat, pi)
          return match (c0 == 36) and (pi + 1 == end):
            true -> match si == slen:
              true -> Cons(si, Nil)
              false -> Nil
            false -> match c0 == 40:
              true -> do:
                let close = _rxFindGroupClose(pat, pi + 1, end, 1)
                return match close < 0:
                  true -> do:
                    let a0 = _rxParseAtom(pat, pi)
                    let next0 = match a0:
                      RxAny(n) -> n
                      RxChar(_c, n) -> n
                      RxClass(_cls, n) -> n
                      RxBoundary(n) -> n
                    let q = _rxParseQuant(pat, next0, end)
                    return match q.kind == 0:
                      true -> match _rxAtomMatches(a0, s, si):
                        true -> _rxMatchEnds(pat, next0, end, s, si + _rxConsumeLen(a0))
                        false -> Nil
                      false -> match q.kind == 42:
                        true -> match q.lazy:
                          true -> _rxMatchEndsStarLazy(a0, pat, q.next, end, s, si)
                          false -> _rxMatchEndsStarGreedy(a0, pat, q.next, end, s, si)
                        false -> match q.kind == 43:
                          true -> match _rxAtomMatches(a0, s, si):
                            true -> match q.lazy:
                              true -> _rxMatchEndsStarLazy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0))
                              false -> _rxMatchEndsStarGreedy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0))
                            false -> Nil
                          false -> match q.kind == 63:
                            true -> do:
                              let z0 = _rxMatchEnds(pat, q.next, end, s, si)
                              return match _rxAtomMatches(a0, s, si):
                                true -> match q.lazy:
                                  true -> append(z0, _rxMatchEnds(pat, q.next, end, s, si + _rxConsumeLen(a0)))
                                  false -> append(_rxMatchEnds(pat, q.next, end, s, si + _rxConsumeLen(a0)), z0)
                                false -> z0
                            false -> Nil
                  false -> do:
                    let qg = _rxParseQuant(pat, close + 1, end)
                    return match qg.kind == 0:
                      true -> do:
                        let inner = _rxMatchEnds(pat, pi + 1, close, s, si)
                        return _rxMatchEndsFromList(inner, pat, close + 1, end, s)
                      false -> match qg.kind == 42:
                        true -> _rxMatchEndsGroupStar(pat, pi, close, qg.next, end, s, si, qg.lazy)
                        false -> match qg.kind == 43:
                          true -> _rxMatchEndsGroupPlus(pat, pi, close, qg.next, end, s, si, qg.lazy)
                          false -> match qg.kind == 63:
                            true -> do:
                              let inner = _rxMatchEnds(pat, pi + 1, close, s, si)
                              let z0 = _rxMatchEnds(pat, qg.next, end, s, si)
                              let one = _rxMatchEndsFromList(inner, pat, qg.next, end, s)
                              return match qg.lazy:
                                true -> append(z0, one)
                                false -> append(one, z0)
                            false -> Nil
              false -> do:
                let a0 = _rxParseAtom(pat, pi)
                let next0 = match a0:
                  RxAny(n) -> n
                  RxChar(_c, n) -> n
                  RxClass(_cls, n) -> n
                  RxBoundary(n) -> n
                let q = _rxParseQuant(pat, next0, end)
                return match q.kind == 0:
                  true -> match _rxAtomMatches(a0, s, si):
                    true -> _rxMatchEnds(pat, next0, end, s, si + _rxConsumeLen(a0))
                    false -> Nil
                  false -> match q.kind == 42:
                    true -> match q.lazy:
                      true -> _rxMatchEndsStarLazy(a0, pat, q.next, end, s, si)
                      false -> _rxMatchEndsStarGreedy(a0, pat, q.next, end, s, si)
                    false -> match q.kind == 43:
                      true -> match _rxAtomMatches(a0, s, si):
                        true -> match q.lazy:
                          true -> _rxMatchEndsStarLazy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0))
                          false -> _rxMatchEndsStarGreedy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0))
                        false -> Nil
                      false -> match q.kind == 63:
                        true -> do:
                          let z0 = _rxMatchEnds(pat, q.next, end, s, si)
                          return match _rxAtomMatches(a0, s, si):
                            true -> match q.lazy:
                              true -> append(z0, _rxMatchEnds(pat, q.next, end, s, si + _rxConsumeLen(a0)))
                              false -> append(_rxMatchEnds(pat, q.next, end, s, si + _rxConsumeLen(a0)), z0)
                            false -> z0
                        false -> Nil

type _RxClassItem = RxLit(Int, Int) | RxDigit(Int) | RxWord(Int) | RxSpace(Int)

fn _rxClassItemNext(it: _RxClassItem) -> Int = match it:
  RxLit(_c, next) -> next
  RxDigit(next) -> next
  RxWord(next) -> next
  RxSpace(next) -> next

fn _rxClassItemIsLit(it: _RxClassItem) -> Bool = match it:
  RxLit(_c, _next) -> true
  _ -> false

fn _rxClassItemLitCode(it: _RxClassItem) -> Int = match it:
  RxLit(c, _next) -> c
  _ -> 0

fn _rxParseClassItem(pat: Str, i: Int) -> _RxClassItem = do:
  let c = _rxCodeAt(pat, i)
  let plen = _rxLen(pat)
  return match c == 92 and i + 1 < plen:
    true -> do:
      let e = _rxCodeAt(pat, i + 1)
      return match e == 100:
        true -> RxDigit(i + 2)
        false -> match e == 119:
          true -> RxWord(i + 2)
          false -> match e == 115:
            true -> RxSpace(i + 2)
            false -> RxLit(e, i + 2)
    false -> RxLit(c, i + 1)

type _RxParseClassAcc = { cls: _RxClass, next: Int, ok: Bool }

fn _rxParseClassLoop(pat: Str, i: Int, invert: Bool, ranges: List[_RxRange], digit: Bool, word: Bool, space: Bool) -> _RxParseClassAcc = do:
  let plen = _rxLen(pat)
  return match i >= plen:
    true -> { cls = { invert = invert, ranges = ranges, digit = digit, word = word, space = space }, next = i, ok = false }
    false -> do:
      let c = _rxCodeAt(pat, i)
      return match c == 93:
        true -> { cls = { invert = invert, ranges = ranges, digit = digit, word = word, space = space }, next = i + 1, ok = true }
        false -> do:
          let it1 = _rxParseClassItem(pat, i)
          let i1 = _rxClassItemNext(it1)
          let doRange = match _rxClassItemIsLit(it1) and i1 + 1 < plen and _rxCodeAt(pat, i1) == 45 and _rxCodeAt(pat, i1 + 1) != 93:
            true -> true
            false -> false
          return match doRange:
            true -> do:
              let it2 = _rxParseClassItem(pat, i1 + 1)
              return match _rxClassItemIsLit(it2):
                true -> do:
                  let r = { lo = _rxClassItemLitCode(it1), hi = _rxClassItemLitCode(it2) }
                  let i2 = _rxClassItemNext(it2)
                  return _rxParseClassLoop(pat, i2, invert, Cons(r, ranges), digit, word, space)
                false -> do:
                  let r = { lo = _rxClassItemLitCode(it1), hi = _rxClassItemLitCode(it1) }
                  let d2 = digit or match it2:
                    RxDigit(_n) -> true
                    _ -> false
                  let w2 = word or match it2:
                    RxWord(_n) -> true
                    _ -> false
                  let s2 = space or match it2:
                    RxSpace(_n) -> true
                    _ -> false
                  let r2 = Cons({ lo = 45, hi = 45 }, Cons(r, ranges))
                  let i2 = _rxClassItemNext(it2)
                  return _rxParseClassLoop(pat, i2, invert, r2, d2, w2, s2)
            false -> do:
              let ranges2 = match _rxClassItemIsLit(it1):
                true -> Cons({ lo = _rxClassItemLitCode(it1), hi = _rxClassItemLitCode(it1) }, ranges)
                false -> ranges
              let digit2 = digit or match it1:
                RxDigit(_n) -> true
                _ -> false
              let word2 = word or match it1:
                RxWord(_n) -> true
                _ -> false
              let space2 = space or match it1:
                RxSpace(_n) -> true
                _ -> false
              return _rxParseClassLoop(pat, i1, invert, ranges2, digit2, word2, space2)

fn _rxParseClass(pat: Str, pi: Int) -> _RxParseClassAcc = do:
  let plen = _rxLen(pat)
  let invert = pi + 1 < plen and _rxCodeAt(pat, pi + 1) == 94
  let i0 = match invert:
    true -> pi + 2
    false -> pi + 1
  let ranges0 = match i0 < plen and _rxCodeAt(pat, i0) == 93:
    true -> Cons({ lo = 93, hi = 93 }, Nil)
    false -> Nil
  let i1 = match i0 < plen and _rxCodeAt(pat, i0) == 93:
    true -> i0 + 1
    false -> i0
  let ranges1 = match i1 < plen and _rxCodeAt(pat, i1) == 45:
    true -> Cons({ lo = 45, hi = 45 }, ranges0)
    false -> ranges0
  let i2 = match i1 < plen and _rxCodeAt(pat, i1) == 45:
    true -> i1 + 1
    false -> i1
  return _rxParseClassLoop(pat, i2, invert, ranges1, false, false, false)

fn _rxParseAtom(pat: Str, pi: Int) -> _RxAtom = do:
  let c = _rxCodeAt(pat, pi)
  let plen = _rxLen(pat)
  return match c == 91:
    true -> do:
      let acc = _rxParseClass(pat, pi)
      return match acc.ok:
        true -> RxClass({ invert = acc.cls.invert, ranges = reverse(acc.cls.ranges), digit = acc.cls.digit, word = acc.cls.word, space = acc.cls.space }, acc.next)
        false -> RxChar(c, pi + 1)
    false -> match c == 92:
      true -> match pi + 1 < plen:
        true -> do:
          let e = _rxCodeAt(pat, pi + 1)
          let cls = { invert = false, ranges = nil(), digit = e == 100, word = e == 119, space = e == 115 }
          return match e == 98:
            true -> RxBoundary(pi + 2)
            false -> match cls.digit or cls.word or cls.space:
              true -> RxClass(cls, pi + 2)
              false -> RxChar(e, pi + 2)
        false -> RxChar(c, pi + 1)
      false -> match c == 46:
        true -> RxAny(pi + 1)
        false -> RxChar(c, pi + 1)

fn _rxMatchHere(pat: Str, pi: Int, s: Str, si: Int) -> Bool = _rxHasAny(_rxMatchEnds(pat, pi, _rxLen(pat), s, si))

fn _rxSearch(pat: Str, s: Str, si: Int) -> Bool = do:
  let slen = _rxLen(s)
  return match _rxMatchHere(pat, 0, s, si):
    true -> true
    false -> match si >= slen:
      true -> false
      false -> _rxSearch(pat, s, si + 1)

fn isMatch(r: Regex, s: Str) -> Bool = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  return match plen > 0 and _rxCodeAt(pat, 0) == 94:
    true -> _rxMatchHere(pat, 1, s, 0)
    false -> _rxSearch(pat, s, 0)

fn _rxFindFirstFrom(pat: Str, s: Str, si: Int) -> Option[Int] = do:
  let slen = _rxLen(s)
  return match _rxMatchHere(pat, 0, s, si):
    true -> Some(si)
    false -> match si >= slen:
      true -> None
      false -> _rxFindFirstFrom(pat, s, si + 1)

fn _rxFirstEnd0(ends: List[Int]) -> Int = match ends:
  Nil -> 0 - 1
  Cons(x, _rest) -> x

fn _rxFindFirstSpanFrom(pat: Str, pi: Int, end: Int, s: Str, si: Int) -> Option[RxSpan] = do:
  let slen = _rxLen(s)
  let ends = _rxMatchEnds(pat, pi, end, s, si)
  return match _rxHasAny(ends):
    true -> do:
      let e = _rxFirstEnd0(ends)
      return Some({ start = si, end = e })
    false -> match si >= slen:
      true -> None
      false -> _rxFindFirstSpanFrom(pat, pi, end, s, si + 1)

fn findFirstSpan(r: Regex, s: Str) -> Option[RxSpan] = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  return match plen > 0 and _rxCodeAt(pat, 0) == 94:
    true -> do:
      let ends = _rxMatchEnds(pat, 1, plen, s, 0)
      return match _rxHasAny(ends):
        true -> Some({ start = 0, end = _rxFirstEnd0(ends) })
        false -> None
    false -> _rxFindFirstSpanFrom(pat, 0, plen, s, 0)

fn _rxFindAllSpansAcc(pat: Str, pi: Int, end: Int, s: Str, si: Int, acc: List[RxSpan]) -> List[RxSpan] = do:
  let slen = _rxLen(s)
  return match si > slen:
    true -> reverse(acc)
    false -> do:
      let ends = _rxMatchEnds(pat, pi, end, s, si)
      return match _rxHasAny(ends):
        true -> do:
          let e = _rxFirstEnd0(ends)
          let acc2 = Cons({ start = si, end = e }, acc)
          let nextSi = match e > si:
            true -> e
            false -> si + 1
          return _rxFindAllSpansAcc(pat, pi, end, s, nextSi, acc2)
        false -> match si >= slen:
          true -> reverse(acc)
          false -> _rxFindAllSpansAcc(pat, pi, end, s, si + 1, acc)

fn findAllSpans(r: Regex, s: Str) -> List[RxSpan] = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  return match plen > 0 and _rxCodeAt(pat, 0) == 94:
    true -> do:
      let ends = _rxMatchEnds(pat, 1, plen, s, 0)
      return match _rxHasAny(ends):
        true -> Cons({ start = 0, end = _rxFirstEnd0(ends) }, Nil)
        false -> Nil
    false -> _rxFindAllSpansAcc(pat, 0, plen, s, 0, Nil)

fn findFirst(r: Regex, s: Str) -> Option[Str] = do:
  let sp = findFirstSpan(r, s)
  return match sp:
    None -> None
    Some(v) -> Some(strSlice(s, v.start, v.end))

fn _rxCapPut(caps: List[RxCapture], idx: Int, start: Int, end: Int) -> List[RxCapture] = match caps:
  Nil -> Cons({ idx = idx, start = start, end = end }, Nil)
  Cons(c, rest) -> match c.idx == idx:
    true -> Cons({ idx = idx, start = start, end = end }, rest)
    false -> Cons(c, _rxCapPut(rest, idx, start, end))

fn _rxCapMerge(a: List[RxCapture], b: List[RxCapture]) -> List[RxCapture] = match b:
  Nil -> a
  Cons(c, rest) -> _rxCapMerge(_rxCapPut(a, c.idx, c.start, c.end), rest)

fn _rxCapAttach(caps: List[RxCapture], rs: List[_RxCapRes]) -> List[_RxCapRes] = match rs:
  Nil -> Nil
  Cons(r, rest) -> Cons({ end = r.end, caps = _rxCapMerge(caps, r.caps) }, _rxCapAttach(caps, rest))

fn _rxMatchCapsContinue(pat: Str, pi: Int, end: Int, s: Str, si: Int, caps: List[RxCapture]) -> List[_RxCapRes] = _rxCapAttach(caps, _rxMatchCaps(pat, pi, end, s, si))

fn _rxMatchCapsFromList(rs: List[_RxCapRes], pat: Str, pi: Int, end: Int, s: Str) -> List[_RxCapRes] = match rs:
  Nil -> Nil
  Cons(r, rest) -> append(_rxMatchCapsContinue(pat, pi, end, s, r.end, r.caps), _rxMatchCapsFromList(rest, pat, pi, end, s))

fn _rxMatchCapsStarGreedy(a: _RxAtom, pat: Str, next: Int, end: Int, s: Str, si: Int, caps: List[RxCapture]) -> List[_RxCapRes] = do:
  let base = _rxMatchCapsContinue(pat, next, end, s, si, caps)
  return match _rxAtomMatches(a, s, si) and _rxAtomConsumes(a):
    true -> append(_rxMatchCapsStarGreedy(a, pat, next, end, s, si + 1, caps), base)
    false -> base

fn _rxMatchCapsStarLazy(a: _RxAtom, pat: Str, next: Int, end: Int, s: Str, si: Int, caps: List[RxCapture]) -> List[_RxCapRes] = do:
  let base = _rxMatchCapsContinue(pat, next, end, s, si, caps)
  return match _rxAtomMatches(a, s, si) and _rxAtomConsumes(a):
    true -> append(base, _rxMatchCapsStarLazy(a, pat, next, end, s, si + 1, caps))
    false -> base

fn _rxMatchCapsGroupOnce(pat: Str, pi: Int, close: Int, s: Str, si: Int) -> List[_RxCapRes] = do:
  let inner = _rxMatchCaps(pat, pi + 1, close, s, si)
  let idx = _rxGroupIndexAt(pat, pi)
  return _rxCapGroupEnds(inner, idx, si)

fn _rxCapGroupEnds(inner: List[_RxCapRes], idx: Int, start: Int) -> List[_RxCapRes] = match inner:
  Nil -> Nil
  Cons(r, rest) -> do:
    let caps2 = _rxCapPut(r.caps, idx, start, r.end)
    return Cons({ end = r.end, caps = caps2 }, _rxCapGroupEnds(rest, idx, start))

fn _rxMatchCapsGroupStar(pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, caps: List[RxCapture], lazy: Bool) -> List[_RxCapRes] = do:
  let inner = _rxMatchCapsGroupOnce(pat, pi, close, s, si)
  let rec = _rxMatchCapsGroupStarFromList(inner, pat, pi, close, next, end, s, si, caps, lazy)
  let base = _rxMatchCapsContinue(pat, next, end, s, si, caps)
  return match lazy:
    true -> append(base, rec)
    false -> append(rec, base)

fn _rxMatchCapsGroupStarFromList(rs: List[_RxCapRes], pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, caps: List[RxCapture], lazy: Bool) -> List[_RxCapRes] = match rs:
  Nil -> Nil
  Cons(r, rest) -> do:
    let cur = match r.end == si:
      true -> Nil
      false -> _rxMatchCapsGroupStar(pat, pi, close, next, end, s, r.end, _rxCapMerge(caps, r.caps), lazy)
    return append(cur, _rxMatchCapsGroupStarFromList(rest, pat, pi, close, next, end, s, si, caps, lazy))

fn _rxMatchCapsGroupPlus(pat: Str, pi: Int, close: Int, next: Int, end: Int, s: Str, si: Int, caps: List[RxCapture], lazy: Bool) -> List[_RxCapRes] = do:
  let inner = _rxMatchCapsGroupOnce(pat, pi, close, s, si)
  return _rxMatchCapsGroupStarFromList(inner, pat, pi, close, next, end, s, si, caps, lazy)

fn _rxMatchCaps(pat: Str, pi: Int, end: Int, s: Str, si: Int) -> List[_RxCapRes] = do:
  let slen = _rxLen(s)
  return match pi >= end:
    true -> Cons({ end = si, caps = Nil }, Nil)
    false -> do:
      let bar = _rxFindTopBar(pat, pi, end, 0)
      return match bar >= 0:
        true -> append(_rxMatchCaps(pat, pi, bar, s, si), _rxMatchCaps(pat, bar + 1, end, s, si))
        false -> do:
          let c0 = _rxCodeAt(pat, pi)
          return match (c0 == 36) and (pi + 1 == end):
            true -> match si == slen:
              true -> Cons({ end = si, caps = Nil }, Nil)
              false -> Nil
            false -> match c0 == 40:
              true -> do:
                let close = _rxFindGroupClose(pat, pi + 1, end, 1)
                return match close < 0:
                  true -> do:
                    let a0 = _rxParseAtom(pat, pi)
                    let next0 = match a0:
                      RxAny(n) -> n
                      RxChar(_c, n) -> n
                      RxClass(_cls, n) -> n
                      RxBoundary(n) -> n
                    let q = _rxParseQuant(pat, next0, end)
                    return match q.kind == 0:
                      true -> match _rxAtomMatches(a0, s, si):
                        true -> _rxMatchCapsContinue(pat, next0, end, s, si + _rxConsumeLen(a0), Nil)
                        false -> Nil
                      false -> match q.kind == 42:
                        true -> match q.lazy:
                          true -> _rxMatchCapsStarLazy(a0, pat, q.next, end, s, si, Nil)
                          false -> _rxMatchCapsStarGreedy(a0, pat, q.next, end, s, si, Nil)
                        false -> match q.kind == 43:
                          true -> match _rxAtomMatches(a0, s, si):
                            true -> match q.lazy:
                              true -> _rxMatchCapsStarLazy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0), Nil)
                              false -> _rxMatchCapsStarGreedy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0), Nil)
                            false -> Nil
                          false -> match q.kind == 63:
                            true -> do:
                              let z0 = _rxMatchCapsContinue(pat, q.next, end, s, si, Nil)
                              return match _rxAtomMatches(a0, s, si):
                                true -> match q.lazy:
                                  true -> append(z0, _rxMatchCapsContinue(pat, q.next, end, s, si + _rxConsumeLen(a0), Nil))
                                  false -> append(_rxMatchCapsContinue(pat, q.next, end, s, si + _rxConsumeLen(a0), Nil), z0)
                                false -> z0
                            false -> Nil
                  false -> do:
                    let qg = _rxParseQuant(pat, close + 1, end)
                    return match qg.kind == 0:
                      true -> do:
                        let inner = _rxMatchCapsGroupOnce(pat, pi, close, s, si)
                        return _rxMatchCapsFromList(inner, pat, close + 1, end, s)
                      false -> match qg.kind == 42:
                        true -> _rxMatchCapsGroupStar(pat, pi, close, qg.next, end, s, si, Nil, qg.lazy)
                        false -> match qg.kind == 43:
                          true -> _rxMatchCapsGroupPlus(pat, pi, close, qg.next, end, s, si, Nil, qg.lazy)
                          false -> match qg.kind == 63:
                            true -> do:
                              let inner = _rxMatchCapsGroupOnce(pat, pi, close, s, si)
                              let z0 = _rxMatchCapsContinue(pat, qg.next, end, s, si, Nil)
                              let one = _rxMatchCapsFromList(inner, pat, qg.next, end, s)
                              return match qg.lazy:
                                true -> append(z0, one)
                                false -> append(one, z0)
                            false -> Nil
              false -> do:
                let a0 = _rxParseAtom(pat, pi)
                let next0 = match a0:
                  RxAny(n) -> n
                  RxChar(_c, n) -> n
                  RxClass(_cls, n) -> n
                  RxBoundary(n) -> n
                let q = _rxParseQuant(pat, next0, end)
                return match q.kind == 0:
                  true -> match _rxAtomMatches(a0, s, si):
                    true -> _rxMatchCapsContinue(pat, next0, end, s, si + _rxConsumeLen(a0), Nil)
                    false -> Nil
                  false -> match q.kind == 42:
                    true -> match q.lazy:
                      true -> _rxMatchCapsStarLazy(a0, pat, q.next, end, s, si, Nil)
                      false -> _rxMatchCapsStarGreedy(a0, pat, q.next, end, s, si, Nil)
                    false -> match q.kind == 43:
                      true -> match _rxAtomMatches(a0, s, si):
                        true -> match q.lazy:
                          true -> _rxMatchCapsStarLazy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0), Nil)
                          false -> _rxMatchCapsStarGreedy(a0, pat, q.next, end, s, si + _rxConsumeLen(a0), Nil)
                        false -> Nil
                      false -> match q.kind == 63:
                        true -> do:
                          let z0 = _rxMatchCapsContinue(pat, q.next, end, s, si, Nil)
                          return match _rxAtomMatches(a0, s, si):
                            true -> match q.lazy:
                              true -> append(z0, _rxMatchCapsContinue(pat, q.next, end, s, si + _rxConsumeLen(a0), Nil))
                              false -> append(_rxMatchCapsContinue(pat, q.next, end, s, si + _rxConsumeLen(a0), Nil), z0)
                            false -> z0
                        false -> Nil

fn _rxGroupIndexAt(pat: Str, target: Int) -> Int = _rxGroupIndexAcc(pat, 0, target, 0)

fn _rxGroupIndexAcc(pat: Str, i: Int, target: Int, idx: Int) -> Int = match i > target or i >= _rxLen(pat):
  true -> idx
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92 and i + 1 < _rxLen(pat):
      true -> _rxGroupIndexAcc(pat, i + 2, target, idx)
      false -> match c == 91:
        true -> do:
          let j = _rxFindClassEnd(pat, i + 1, _rxLen(pat))
          return match j < 0:
            true -> idx
            false -> _rxGroupIndexAcc(pat, j + 1, target, idx)
        false -> match c == 40:
          true -> match i == target:
            true -> idx + 1
            false -> _rxGroupIndexAcc(pat, i + 1, target, idx + 1)
          false -> _rxGroupIndexAcc(pat, i + 1, target, idx)

fn _rxGroupCount(pat: Str) -> Int = _rxGroupCountAcc(pat, 0, _rxLen(pat), 0)

fn _rxGroupCountAcc(pat: Str, i: Int, end: Int, count: Int) -> Int = match i >= end:
  true -> count
  false -> do:
    let c = _rxCodeAt(pat, i)
    return match c == 92 and i + 1 < end:
      true -> _rxGroupCountAcc(pat, i + 2, end, count)
      false -> match c == 91:
        true -> do:
          let j = _rxFindClassEnd(pat, i + 1, end)
          return match j < 0:
            true -> count
            false -> _rxGroupCountAcc(pat, j + 1, end, count)
        false -> match c == 40:
          true -> _rxGroupCountAcc(pat, i + 1, end, count + 1)
          false -> _rxGroupCountAcc(pat, i + 1, end, count)

fn _rxCapSpanAt(caps: List[RxCapture], idx: Int) -> Option[RxSpan] = match caps:
  Nil -> None
  Cons(c, rest) -> match c.idx == idx:
    true -> Some({ start = c.start, end = c.end })
    false -> _rxCapSpanAt(rest, idx)

fn _rxCapStrsAcc(s: Str, i: Int, n: Int, start: Int, end: Int, caps: List[RxCapture], acc: List[Str]) -> List[Str] = match i > n:
  true -> reverse(acc)
  false -> match i == 0:
    true -> _rxCapStrsAcc(s, i + 1, n, start, end, caps, Cons(strSlice(s, start, end), acc))
    false -> match _rxCapSpanAt(caps, i):
      None -> _rxCapStrsAcc(s, i + 1, n, start, end, caps, Cons("", acc))
      Some(sp) -> _rxCapStrsAcc(s, i + 1, n, start, end, caps, Cons(strSlice(s, sp.start, sp.end), acc))

fn _rxFirstCapRes(rs: List[_RxCapRes]) -> Option[_RxCapRes] = match rs:
  Nil -> None
  Cons(r, _rest) -> Some(r)

fn findFirstCaptures(r: Regex, s: Str) -> Option[List[Str]] = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  let count = _rxGroupCount(pat)
  return match plen > 0 and _rxCodeAt(pat, 0) == 94:
    true -> do:
      let rs = _rxMatchCaps(pat, 1, plen, s, 0)
      return match _rxFirstCapRes(rs):
        Some(r0) -> Some(_rxCapStrsAcc(s, 0, count, 0, r0.end, r0.caps, Nil))
        None -> None
    false -> do:
      let r0 = _rxFindFirstCapMatchFrom(pat, 0, plen, s, 0)
      return match r0:
        None -> None
        Some(rm) -> Some(_rxCapStrsAcc(s, 0, count, rm.start, rm.end, rm.caps, Nil))

type _RxCapMatch = { start: Int, end: Int, caps: List[RxCapture] }

fn _rxFindFirstCapMatchFrom(pat: Str, pi: Int, end: Int, s: Str, si: Int) -> Option[_RxCapMatch] = do:
  let slen = _rxLen(s)
  return match si > slen:
    true -> None
    false -> do:
      let rs = _rxMatchCaps(pat, pi, end, s, si)
      return match _rxFirstCapRes(rs):
        Some(r) -> Some({ start = si, end = r.end, caps = r.caps })
        None -> match si >= slen:
          true -> None
          false -> _rxFindFirstCapMatchFrom(pat, pi, end, s, si + 1)

fn _rxGroupAt(groups: List[Str], idx: Int) -> Str = match idx < 0:
  true -> ""
  false -> match groups:
    Nil -> ""
    Cons(x, rest) -> match idx == 0:
      true -> x
      false -> _rxGroupAt(rest, idx - 1)

type _RxIntRes = { ok: Bool, i: Int, out: Int }

fn _rxParseDigitsAcc(s: Str, i: Int, acc: Int, seen: Bool) -> _RxIntRes = match i >= _rxLen(s):
  true -> { ok = seen, i = i, out = acc }
  false -> do:
    let c = _rxCodeAt(s, i)
    return match c >= 48 and c <= 57:
      true -> _rxParseDigitsAcc(s, i + 1, acc * 10 + (c - 48), true)
      false -> { ok = seen, i = i, out = acc }

fn _rxConcatPieces(xs: List[Str]) -> Str = match xs:
  Nil -> ""
  Cons(x, rest) -> x + _rxConcatPieces(rest)

fn _rxReplaceScan(repl: Str, i: Int, groups: List[Str], pieces: List[Str]) -> Str = do:
  let n = _rxLen(repl)
  return match i >= n:
    true -> _rxConcatPieces(reverse(pieces))
    false -> do:
      let c = _rxCodeAt(repl, i)
      return match c == 36 and i + 1 < n:
        true -> do:
          let c1 = _rxCodeAt(repl, i + 1)
          return match c1 == 36:
            true -> _rxReplaceScan(repl, i + 2, groups, Cons("$", pieces))
            false -> do:
              let r = _rxParseDigitsAcc(repl, i + 1, 0, false)
              return match r.ok:
                true -> do:
                  let g = _rxGroupAt(groups, r.out)
                  return _rxReplaceScan(repl, r.i, groups, Cons(g, pieces))
                false -> _rxReplaceScan(repl, i + 1, groups, Cons("$", pieces))
        false -> _rxReplaceScan(repl, i + 1, groups, Cons(_rxChar(c), pieces))

fn replace(r: Regex, s: Str, repl: Str) -> Str = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  let anchored = plen > 0 and _rxCodeAt(pat, 0) == 94
  let m = match anchored:
    true -> do:
      let rs = _rxMatchCaps(pat, 1, plen, s, 0)
      match _rxFirstCapRes(rs):
        None -> None
        Some(r0) -> Some({ start = 0, end = r0.end, caps = r0.caps })
    false -> _rxFindFirstCapMatchFrom(pat, 0, plen, s, 0)
  return match m:
    None -> s
    Some(v) -> do:
      let count = _rxGroupCount(pat)
      let groups = _rxCapStrsAcc(s, 0, count, v.start, v.end, v.caps, Nil)
      let rep = _rxReplaceScan(repl, 0, groups, Nil)
      return strSlice(s, 0, v.start) + rep + strSlice(s, v.end, _rxLen(s))

fn replaceAll(r: Regex, s: Str, repl: Str) -> Str = do:
  let pat = r.pat
  let plen = _rxLen(pat)
  let anchored = plen > 0 and _rxCodeAt(pat, 0) == 94
  return match anchored:
    true -> replace(r, s, repl)
    false -> _rxReplaceAllFrom(pat, plen, s, 0, repl, Nil)

fn _rxReplaceAllFrom(pat: Str, plen: Int, s: Str, si: Int, repl: Str, pieces: List[Str]) -> Str = do:
  let m = _rxFindFirstCapMatchFrom(pat, 0, plen, s, si)
  return match m:
    None -> do:
      let tail = strSlice(s, si, _rxLen(s))
      return _rxConcatPieces(reverse(Cons(tail, pieces)))
    Some(v) -> do:
      let count = _rxGroupCount(pat)
      let groups = _rxCapStrsAcc(s, 0, count, v.start, v.end, v.caps, Nil)
      let rep = _rxReplaceScan(repl, 0, groups, Nil)
      let prefix = strSlice(s, si, v.start)
      let pieces2 = Cons(rep, Cons(prefix, pieces))
      let next = match v.end > v.start:
        true -> v.end
        false -> v.start + 1
      return _rxReplaceAllFrom(pat, plen, s, next, repl, pieces2)
