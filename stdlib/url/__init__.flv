use collections.list
use stringlib

type UrlQueryParam = { key: Str, value: Str }

fn _isDigit(c: Int) -> Bool = c >= 48 and c <= 57

fn _isUpper(c: Int) -> Bool = c >= 65 and c <= 90

fn _isLower(c: Int) -> Bool = c >= 97 and c <= 122

fn _isAlpha(c: Int) -> Bool = _isUpper(c) or _isLower(c)

fn _isUnreserved(c: Int) -> Bool = _isAlpha(c) or _isDigit(c) or c == 45 or c == 46 or c == 95 or c == 126

fn _hexDigit(n: Int) -> Str = match n < 10:
  true -> strFromCodePoint(48 + n)
  false -> strFromCodePoint(65 + (n - 10))

fn _hexByte(x: Int) -> Str = do:
  let hi = x / 16
  let lo = x - (hi * 16)
  return _hexDigit(hi) + _hexDigit(lo)

fn _hexVal(c: Int) -> Int = match _isDigit(c):
  true -> c - 48
  false -> match c >= 65 and c <= 70:
    true -> 10 + (c - 65)
    false -> match c >= 97 and c <= 102:
      true -> 10 + (c - 97)
      false -> 0 - 1

fn _encodeAcc(s: Str, i: Int, n: Int, plusForSpace: Bool, acc: Str) -> Str = match i >= n:
  true -> acc
  false -> do:
    let c = strCode(s, i)
    let part = match plusForSpace and c == 32:
      true -> "+"
      false -> match _isUnreserved(c):
        true -> strFromCodePoint(c)
        false -> "%" + _hexByte(c)
    return _encodeAcc(s, i + 1, n, plusForSpace, acc + part)

fn _decodeAcc(s: Str, i: Int, n: Int, plusAsSpace: Bool, acc: Str) -> Result[Str, Str] = match i >= n:
  true -> Ok(acc)
  false -> do:
    let c = strCode(s, i)
    return match c == 37:
      true -> do:
        if i + 2 >= n:
          return Err("url: incomplete percent escape")
        let h = _hexVal(strCode(s, i + 1))
        let l = _hexVal(strCode(s, i + 2))
        return match h < 0 or l < 0:
          true -> Err("url: invalid percent escape")
          false -> _decodeAcc(s, i + 3, n, plusAsSpace, acc + strFromCodePoint(h * 16 + l))
      false -> match plusAsSpace and c == 43:
        true -> _decodeAcc(s, i + 1, n, plusAsSpace, acc + " ")
        false -> _decodeAcc(s, i + 1, n, plusAsSpace, acc + strFromCodePoint(c))

fn encodeComponent(s: Str) -> Str = _encodeAcc(s, 0, strLength(s), false, "")

fn decodeComponent(s: Str) -> Result[Str, Str] = _decodeAcc(s, 0, strLength(s), false, "")

fn queryEncode(s: Str) -> Str = _encodeAcc(s, 0, strLength(s), true, "")

fn queryDecode(s: Str) -> Result[Str, Str] = _decodeAcc(s, 0, strLength(s), true, "")

fn _queryNoPrefix(q: Str) -> Str = match strLength(q) > 0 and strCode(q, 0) == 63:
  true -> strSliceRange(q, 1, strLength(q))
  false -> q

fn _parseOne(seg: Str) -> Result[UrlQueryParam, Str] = do:
  let eq = strFind(seg, "=", 0)
  let k0 = match eq < 0:
    true -> seg
    false -> strSliceRange(seg, 0, eq)
  let v0 = match eq < 0:
    true -> ""
    false -> strSliceRange(seg, eq + 1, strLength(seg))
  let rk = queryDecode(k0)
  return match rk:
    Err(e) -> Err(e)
    Ok(k) -> do:
      let rv = queryDecode(v0)
      return match rv:
        Err(e) -> Err(e)
        Ok(v) -> Ok({ key = k, value = v })

fn _parseMany(parts: List[Str], acc: List[UrlQueryParam]) -> Result[List[UrlQueryParam], Str] = match parts:
  Nil -> Ok(reverse(acc))
  Cons(seg, rest) -> match strLength(seg) == 0:
    true -> _parseMany(rest, acc)
    false -> do:
      let rp = _parseOne(seg)
      return match rp:
        Err(e) -> Err(e)
        Ok(p) -> _parseMany(rest, Cons(p, acc))

fn queryParse(q: Str) -> Result[List[UrlQueryParam], Str] = do:
  let clean = _queryNoPrefix(q)
  return match strLength(clean) == 0:
    true -> Ok(Nil)
    false -> _parseMany(split(clean, "&"), Nil)

fn _buildMany(parts: List[UrlQueryParam], acc: Str) -> Str = match parts:
  Nil -> acc
  Cons(p, rest) -> do:
    let piece = queryEncode(p.key) + "=" + queryEncode(p.value)
    return match strLength(acc) == 0:
      true -> _buildMany(rest, piece)
      false -> _buildMany(rest, acc + "&" + piece)

fn queryBuild(parts: List[UrlQueryParam]) -> Str = _buildMany(parts, "")
