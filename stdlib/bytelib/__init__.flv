use _bridge_python
use collections.list

fn bytesLen(b: Bytes) -> Int = _pyBytesLen(b)

fn bytesGet(b: Bytes, i: Int) -> Int = _pyBytesGet(b, i)

fn bytesSlice(b: Bytes, start: Int, end: Int) -> Bytes = _pyBytesSlice(b, start, end)

fn bytesConcat(a: Bytes, b: Bytes) -> Bytes = _pyBytesConcat(a, b)

fn bytesFromByte(x: Int) -> Bytes = _pyBytesFromByte(x)

fn _bytesEqAt(h: Bytes, hi: Int, hn: Int, needle: Bytes, ni: Int, nn: Int) -> Bool = match ni >= nn:
  true -> true
  false -> match hi + ni >= hn:
    true -> false
    false -> match bytesGet(h, hi + ni) == bytesGet(needle, ni):
      true -> _bytesEqAt(h, hi, hn, needle, ni + 1, nn)
      false -> false

fn _bytesFindFrom(h: Bytes, needle: Bytes, i: Int, hn: Int, nn: Int) -> Int = match i + nn > hn:
  true -> 0 - 1
  false -> match _bytesEqAt(h, i, hn, needle, 0, nn):
    true -> i
    false -> _bytesFindFrom(h, needle, i + 1, hn, nn)

fn bytesFind(h: Bytes, needle: Bytes, start: Int) -> Int = do:
  let hn = bytesLen(h)
  let nn = bytesLen(needle)
  return match nn == 0:
    true -> start
    false -> _bytesFindFrom(h, needle, start, hn, nn)

fn bytesStartsWith(h: Bytes, prefix: Bytes) -> Bool = do:
  let hn = bytesLen(h)
  let pn = bytesLen(prefix)
  return match pn > hn:
    true -> false
    false -> _bytesEqAt(h, 0, hn, prefix, 0, pn)

fn bytesEndsWith(h: Bytes, suffix: Bytes) -> Bool = do:
  let hn = bytesLen(h)
  let sn = bytesLen(suffix)
  return match sn > hn:
    true -> false
    false -> _bytesEqAt(h, hn - sn, hn, suffix, 0, sn)

fn _btToListAcc(b: Bytes, i: Int, n: Int) -> List[Int] = match i >= n:
  true -> Nil
  false -> Cons(bytesGet(b, i), _btToListAcc(b, i + 1, n))

fn bytesToList(b: Bytes) -> List[Int] = _btToListAcc(b, 0, bytesLen(b))

fn _btFromList(xs: List[Int]) -> Bytes = match xs:
  Nil -> b""
  Cons(x, rest) -> bytesConcat(bytesFromByte(x), _btFromList(rest))

fn bytesFromList(xs: List[Int]) -> Bytes = _btFromList(xs)

fn bytesConcatAll(xs: List[Bytes]) -> Bytes = match xs:
  Nil -> b""
  Cons(x, rest) -> bytesConcat(x, bytesConcatAll(rest))

type ByteArray = List[Int]

fn byteArrayEmpty() -> ByteArray = Nil

fn byteArrayPush(a: ByteArray, x: Int) -> ByteArray = append(a, Cons(x, Nil))

fn byteArrayToBytes(a: ByteArray) -> Bytes = bytesFromList(a)

fn bytesToByteArray(b: Bytes) -> ByteArray = bytesToList(b)
