type List[T] = Nil | Cons(T, List[T])

fn nil[T]() -> List[T] = Nil

fn cons[T](x: T, xs: List[T]) -> List[T] = Cons(x, xs)

fn isEmpty[T](xs: List[T]) -> Bool = match xs:
  Nil -> true
  Cons(_, _) -> false

fn head[T](xs: List[T]) -> Option[T] = match xs:
  Nil -> None
  Cons(x, _) -> Some(x)

fn tail[T](xs: List[T]) -> Option[List[T]] = match xs:
  Nil -> None
  Cons(_, rest) -> Some(rest)

fn length[T](xs: List[T]) -> Int = match xs:
  Nil -> 0
  Cons(_, rest) -> 1 + length(rest)

fn _revAcc[T](xs: List[T], acc: List[T]) -> List[T] = match xs:
  Nil -> acc
  Cons(x, rest) -> _revAcc(rest, Cons(x, acc))

fn reverse[T](xs: List[T]) -> List[T] = _revAcc(xs, Nil)

fn append[T](xs: List[T], ys: List[T]) -> List[T] = match xs:
  Nil -> ys
  Cons(x, rest) -> Cons(x, append(rest, ys))
