
type Heap = Empty | Node(Int, Heap, Heap)

type HeapPop = { value: Int, rest: Heap }

fn heapEmpty() -> Heap = Empty

fn heapIsEmpty(h: Heap) -> Bool = match h:
  Empty -> true
  Node(_, _, _) -> false

fn heapMerge(a: Heap, b: Heap) -> Heap = match a:
  Empty -> b
  Node(x, al, ar) -> match b:
    Empty -> a
    Node(y, bl, br) -> do:
      if x <= y:
        return Node(x, heapMerge(ar, b), al)
      else:
        return Node(y, heapMerge(br, a), bl)

fn heapInsert(x: Int, h: Heap) -> Heap = heapMerge(Node(x, Empty, Empty), h)

fn heapPeek(h: Heap) -> Option[Int] = match h:
  Empty -> None
  Node(x, _, _) -> Some(x)

fn heapPop(h: Heap) -> Option[HeapPop] = match h:
  Empty -> None
  Node(x, l, r) -> Some({ value = x, rest = heapMerge(l, r) })

fn heapPeekOr(h: Heap, default: Int) -> Int = match heapPeek(h):
  None -> default
  Some(x) -> x

fn heapPopOr(h: Heap, default: Int) -> HeapPop = match heapPop(h):
  None -> { value = default, rest = h }
  Some(p) -> p

fn heapSize(h: Heap) -> Int = match h:
  Empty -> 0
  Node(_, l, r) -> 1 + heapSize(l) + heapSize(r)

fn heapFromList(xs: List[Int]) -> Heap = match xs:
  Nil -> heapEmpty()
  Cons(x, rest) -> heapInsert(x, heapFromList(rest))

fn heapInsertAll(xs: List[Int], h: Heap) -> Heap = match xs:
  Nil -> h
  Cons(x, rest) -> heapInsertAll(rest, heapInsert(x, h))

fn _heapToListAcc(h: Heap, acc: List[Int]) -> List[Int] = match heapPop(h):
  None -> acc
  Some(p) -> _heapToListAcc(p.rest, Cons(p.value, acc))

fn heapToSortedList(h: Heap) -> List[Int] = reverse(_heapToListAcc(h, Nil))

fn heapMinOr(h: Heap, default: Int) -> Int = match heapPeek(h):
  None -> default
  Some(x) -> x

