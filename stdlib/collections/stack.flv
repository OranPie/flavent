use collections.list

type Stack[T] = List[T]

type StackPop[T] = { value: T, rest: Stack[T] }

fn stackEmpty[T]() -> Stack[T] = Nil

fn stackIsEmpty[T](s: Stack[T]) -> Bool = isEmpty(s)

fn stackPush[T](s: Stack[T], x: T) -> Stack[T] = Cons(x, s)

fn stackPeek[T](s: Stack[T]) -> Option[T] = match s:
  Nil -> None
  Cons(x, _) -> Some(x)

fn stackPop[T](s: Stack[T]) -> Option[StackPop[T]] = match s:
  Nil -> None
  Cons(x, rest) -> Some({ value = x, rest = rest })

fn stackPeekOr[T](s: Stack[T], default: T) -> T = match stackPeek(s):
  None -> default
  Some(x) -> x

fn stackPopOr[T](s: Stack[T], default: T) -> StackPop[T] = match stackPop(s):
  None -> { value = default, rest = s }
  Some(p) -> p

fn stackSize[T](s: Stack[T]) -> Int = length(s)

fn stackToList[T](s: Stack[T]) -> List[T] = s

fn stackFromList[T](xs: List[T]) -> Stack[T] = xs

fn stackPushAll[T](s: Stack[T], xs: List[T]) -> Stack[T] = match xs:
  Nil -> s
  Cons(x, rest) -> stackPushAll(stackPush(s, x), rest)
