use collections.list

type MapEntry[K, V] = { key: K, value: V }

type Map[K, V] = List[MapEntry[K, V]]

fn mapEmpty[K, V]() -> Map[K, V] = Nil

fn mapGet[K, V](m: Map[K, V], k: K) -> Option[V] = match m:
  Nil -> None
  Cons(e, rest) -> do:
    if e.key == k:
      return Some(e.value)
    else:
      return mapGet(rest, k)

fn mapGetOr[K, V](m: Map[K, V], k: K, default: V) -> V = match mapGet(m, k):
  None -> default
  Some(v) -> v

fn mapPut[K, V](m: Map[K, V], k: K, v: V) -> Map[K, V] = match m:
  Nil -> Cons({ key = k, value = v }, Nil)
  Cons(e, rest) -> do:
    if e.key == k:
      return Cons({ key = k, value = v }, rest)
    else:
      return Cons(e, mapPut(rest, k, v))

fn mapRemove[K, V](m: Map[K, V], k: K) -> Map[K, V] = match m:
  Nil -> Nil
  Cons(e, rest) -> do:
    if e.key == k:
      return rest
    else:
      return Cons(e, mapRemove(rest, k))

fn mapPutAll[K, V](m: Map[K, V], entries: List[MapEntry[K, V]]) -> Map[K, V] = match entries:
  Nil -> m
  Cons(e, rest) -> mapPutAll(mapPut(m, e.key, e.value), rest)

fn mapMerge[K, V](a: Map[K, V], b: Map[K, V]) -> Map[K, V] = mapPutAll(a, b)

fn mapHasKey[K, V](m: Map[K, V], k: K) -> Bool = match mapGet(m, k):
  Some(_) -> true
  None -> false

fn mapKeys[K, V](m: Map[K, V]) -> List[K] = match m:
  Nil -> Nil
  Cons(e, rest) -> Cons(e.key, mapKeys(rest))

fn mapValues[K, V](m: Map[K, V]) -> List[V] = match m:
  Nil -> Nil
  Cons(e, rest) -> Cons(e.value, mapValues(rest))

fn mapSize[K, V](m: Map[K, V]) -> Int = length(m)

fn mapToList[K, V](m: Map[K, V]) -> List[MapEntry[K, V]] = m

fn mapFromList[K, V](xs: List[MapEntry[K, V]]) -> Map[K, V] = xs
