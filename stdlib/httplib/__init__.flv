use _bridge_python
use collections.list
use bytelib
use socket

type Header = { key: Str, value: Str }
type HttpResponse = { status: Int, reason: Str, headers: List[Header], body: Bytes }

type _StrPair = { a: Str, b: Str }
type _StatusInfo = { status: Int, reason: Str }

type _BytesPair = { a: Bytes, b: Bytes }

fn _asciiFromBytesAcc(b: Bytes, i: Int, n: Int, acc: Str) -> Str = match i >= n:
  true -> acc
  false -> _asciiFromBytesAcc(b, i + 1, n, acc + strFromCode(bytesGet(b, i)))

fn asciiFromBytes(b: Bytes) -> Str = _asciiFromBytesAcc(b, 0, bytesLen(b), "")

fn _asciiCodesAcc(s: Str, i: Int, n: Int, acc: List[Int]) -> List[Int] = match i >= n:
  true -> reverse(acc)
  false -> _asciiCodesAcc(s, i + 1, n, Cons(strCodeAt(s, i), acc))

fn asciiToBytes(s: Str) -> Bytes = bytesFromList(_asciiCodesAcc(s, 0, strLen(s), Nil))

fn _strFindAt(h: Str, hi: Int, n: Int, needle: Str, ni: Int, nn: Int) -> Bool = match ni >= nn:
  true -> true
  false -> match hi + ni >= n:
    true -> false
    false -> match strCodeAt(h, hi + ni) == strCodeAt(needle, ni):
      true -> _strFindAt(h, hi, n, needle, ni + 1, nn)
      false -> false

fn _strFindFrom(h: Str, needle: Str, i: Int, n: Int, nn: Int) -> Int = match i + nn > n:
  true -> 0 - 1
  false -> match _strFindAt(h, i, n, needle, 0, nn):
    true -> i
    false -> _strFindFrom(h, needle, i + 1, n, nn)

fn strFind(h: Str, needle: Str, start: Int) -> Int = do:
  let n = strLen(h)
  let nn = strLen(needle)
  return match nn == 0:
    true -> start
    false -> _strFindFrom(h, needle, start, n, nn)

fn _parseIntDigitsAcc(s: Str, i: Int, n: Int, acc: Int) -> Int = match i >= n:
  true -> acc
  false -> do:
    let c = strCodeAt(s, i)
    return match c >= 48 and c <= 57:
      true -> _parseIntDigitsAcc(s, i + 1, n, acc * 10 + (c - 48))
      false -> acc

fn parseIntDigits(s: Str) -> Int = _parseIntDigitsAcc(s, 0, strLen(s), 0)

fn _bytesEqAt(h: Bytes, hi: Int, hn: Int, needle: Bytes, ni: Int, nn: Int) -> Bool = match ni >= nn:
  true -> true
  false -> match hi + ni >= hn:
    true -> false
    false -> match bytesGet(h, hi + ni) == bytesGet(needle, ni):
      true -> _bytesEqAt(h, hi, hn, needle, ni + 1, nn)
      false -> false

fn _bytesFindFrom(h: Bytes, needle: Bytes, i: Int, hn: Int, nn: Int) -> Int = match i + nn > hn:
  true -> 0 - 1
  false -> match _bytesEqAt(h, i, hn, needle, 0, nn):
    true -> i
    false -> _bytesFindFrom(h, needle, i + 1, hn, nn)

fn bytesFind(h: Bytes, needle: Bytes, start: Int) -> Int = do:
  let hn = bytesLen(h)
  let nn = bytesLen(needle)
  return match nn == 0:
    true -> start
    false -> _bytesFindFrom(h, needle, start, hn, nn)

fn _splitLineBytes(b: Bytes) -> _BytesPair = do:
  let crlf = bytesFromList(Cons(13, Cons(10, Nil)))
  let i = bytesFind(b, crlf, 0)
  return match i < 0:
    true -> { a = b, b = b"" }
    false -> { a = bytesSlice(b, 0, i), b = bytesSlice(b, i + 2, bytesLen(b)) }

fn _trimLeftSpacesAcc(s: Str, i: Int, n: Int) -> Str = match i >= n:
  true -> ""
  false -> match strCodeAt(s, i) == 32:
    true -> _trimLeftSpacesAcc(s, i + 1, n)
    false -> strSlice(s, i, n)

fn trimLeftSpaces(s: Str) -> Str = _trimLeftSpacesAcc(s, 0, strLen(s))

fn _parseHeaderLine(line: Str) -> Option[Header] = do:
  let i = strFind(line, ":", 0)
  return match i < 0:
    true -> None
    false -> do:
      let k = strSlice(line, 0, i)
      let v0 = strSlice(line, i + 1, strLen(line))
      let v = trimLeftSpaces(v0)
      return Some({ key = k, value = v })

fn _parseHeadersBytesAcc(b: Bytes, acc: List[Header]) -> List[Header] = match bytesLen(b) == 0:
  true -> reverse(acc)
  false -> do:
    let sp = _splitLineBytes(b)
    let lineB = sp.a
    let restB = sp.b
    return match bytesLen(lineB) == 0:
      true -> reverse(acc)
      false -> do:
        let line = asciiFromBytes(lineB)
        let h = _parseHeaderLine(line)
        return match h:
          Some(v) -> _parseHeadersBytesAcc(restB, Cons(v, acc))
          None -> _parseHeadersBytesAcc(restB, acc)

fn parseHeadersBytes(b: Bytes) -> List[Header] = _parseHeadersBytesAcc(b, Nil)

fn _parseStatusLine(line: Str) -> _StatusInfo = do:
  let i1 = strFind(line, " ", 0)
  return match i1 < 0:
    true -> { status = 0, reason = "" }
    false -> do:
      let i2 = strFind(line, " ", i1 + 1)
      return match i2 < 0:
        true -> { status = parseIntDigits(strSlice(line, i1 + 1, strLen(line))), reason = "" }
        false -> do:
          let codeStr = strSlice(line, i1 + 1, i2)
          let reason = strSlice(line, i2 + 1, strLen(line))
          return { status = parseIntDigits(codeStr), reason = reason }

fn buildGetRequest(host: Str, path: Str) -> Bytes = do:
  let crlf = bytesFromList(Cons(13, Cons(10, Nil)))
  let l1 = asciiToBytes("GET " + path + " HTTP/1.1")
  let l2 = asciiToBytes("Host: " + host)
  let l3 = asciiToBytes("Connection: close")
  let a = bytesConcat(l1, crlf)
  let b = bytesConcat(l2, crlf)
  let c = bytesConcat(l3, crlf)
  return bytesConcat(bytesConcat(bytesConcat(a, b), c), crlf)

fn parseResponse(raw: Bytes) -> Result[HttpResponse, Str] = do:
  let sep = bytesFromList(Cons(13, Cons(10, Cons(13, Cons(10, Nil)))))
  let p = bytesFind(raw, sep, 0)
  return match p < 0:
    true -> Err("bad http response")
    false -> do:
      let headBytes = bytesSlice(raw, 0, p)
      let body = bytesSlice(raw, p + 4, bytesLen(raw))
      let sp = _splitLineBytes(headBytes)
      let statusLine = asciiFromBytes(sp.a)
      let restB = sp.b
      let st = _parseStatusLine(statusLine)
      let headers = parseHeadersBytes(restB)
      return Ok({ status = st.status, reason = st.reason, headers = headers, body = body })

sector httplib:
  fn get(host: Str, port: Int, path: Str) -> Result[HttpResponse, Str] = do:
    let sock = rpc socket.tcpConnect(host, port)?
    let _sent = rpc socket.sendAll(sock, buildGetRequest(host, path))?
    let raw = rpc socket.recvAll(sock, 4096)?
    let _closed = rpc socket.close(sock)
    return parseResponse(raw)