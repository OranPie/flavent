use _bridge_python
use bytelib
use socket.types

sector socket:
  fn tcpConnect(host: Str, port: Int) -> Result[Socket, Str] = rpc _bridge_python.sockTcpConnect(host, port)

  fn tcpConnectPeer(peer: TcpPeer) -> Result[Socket, Str] = tcpConnect(peer.host, peer.port)

  fn tcpListen(host: Str, port: Int, backlog: Int) -> Result[Socket, Str] = rpc _bridge_python.sockTcpListen(host, port, backlog)

  fn tcpListenPeer(peer: TcpPeer, backlog: Int) -> Result[Socket, Str] = tcpListen(peer.host, peer.port, backlog)

  fn tcpAccept(s: Socket) -> Result[TcpAccept, Str] = rpc _bridge_python.sockTcpAccept(s)

  fn send(s: Socket, data: Bytes) -> Result[Int, Str] = rpc _bridge_python.sockSend(s, data)

  fn recv(s: Socket, n: Int) -> Result[Bytes, Str] = rpc _bridge_python.sockRecv(s, n)

  fn close(s: Socket) -> Result[Unit, Str] = rpc _bridge_python.sockClose(s)

  fn shutdown(s: Socket) -> Result[Unit, Str] = rpc _bridge_python.sockShutdown(s)

  fn setTimeoutMillis(s: Socket, ms: Int) -> Result[Unit, Str] = rpc _bridge_python.sockSetTimeoutMillis(s, ms)

  fn sendAll(s: Socket, data: Bytes) -> Result[Unit, Str] = do:
    let n = send(s, data)?
    return match n >= bytesLen(data):
      true -> Ok(())
      false -> sendAll(s, bytesSlice(data, n, bytesLen(data)))

  fn recvAll(s: Socket, chunk: Int) -> Result[Bytes, Str] = do:
    let part = recv(s, chunk)?
    return match bytesLen(part) == 0:
      true -> Ok(b"")
      false -> do:
        let rest = recvAll(s, chunk)?
        return Ok(bytesConcat(part, rest))
