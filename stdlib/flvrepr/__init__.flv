use collections.list
use stringlib

type MetaPair = { key: Str, value: Str }

fn pair(key: Str, value: Str) -> MetaPair = { key = key, value = value }

fn encodePair(p: MetaPair) -> Str = p.key + "=" + p.value

fn encodePairs(xs: List[MetaPair]) -> Str = match xs:
  Nil -> ""
  Cons(x, rest) -> match rest:
    Nil -> encodePair(x)
    Cons(_, _) -> encodePair(x) + ";" + encodePairs(rest)

fn encodeFunctionTarget(target: Str, point: Str, priority: Str, at: Str) -> Str = encodePairs(
  Cons(pair("target", target),
  Cons(pair("point", point),
  Cons(pair("priority", priority),
  Cons(pair("at", at), Nil))))
)

fn _decodeOne(raw: Str) -> MetaPair = match split(raw, "="):
  Nil -> pair("", "")
  Cons(k, rest) -> pair(k, join(rest, "="))

fn _decodePairsFrom(parts: List[Str], acc: List[MetaPair]) -> List[MetaPair] = match parts:
  Nil -> reverse(acc)
  Cons(part, rest) -> match part == "":
    true -> _decodePairsFrom(rest, acc)
    false -> _decodePairsFrom(rest, Cons(_decodeOne(part), acc))

fn decodePairs(meta: Str) -> List[MetaPair] = _decodePairsFrom(split(meta, ";"), Nil)

fn _findPair(xs: List[MetaPair], key: Str) -> Option[Str] = match xs:
  Nil -> None
  Cons(x, rest) -> match x.key == key:
    true -> Some(x.value)
    false -> _findPair(rest, key)

fn metaGet(meta: Str, key: Str) -> Option[Str] = _findPair(decodePairs(meta), key)

fn _upsertAcc(xs: List[MetaPair], key: Str, value: Str, acc: List[MetaPair], seen: Bool) -> List[MetaPair] = match xs:
  Nil -> match seen:
    true -> reverse(acc)
    false -> reverse(Cons(pair(key, value), acc))
  Cons(x, rest) -> match x.key == key:
    true -> _upsertAcc(rest, key, value, Cons(pair(key, value), acc), true)
    false -> _upsertAcc(rest, key, value, Cons(x, acc), seen)

fn metaSet(meta: Str, key: Str, value: Str) -> Str = encodePairs(_upsertAcc(decodePairs(meta), key, value, Nil, false))
