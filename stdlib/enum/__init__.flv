use collections.list
use std.option
use std.result

// Enum helpers (very minimal).
//
// In Flavent, most enums should be modeled as sum types:
//   type Color = Red | Green | Blue
//
// Future directions:
// - Reflection/serialization helpers (toInt/toStr/fromInt/fromStr).
// - Derive-style codegen in the compiler.
// - Stable ordering/hash support.

type EnumCase = { name: Str, tag: Int }

type EnumInfo = { cases: List[EnumCase] }

fn enumInfoEmpty() -> EnumInfo = { cases = Nil }

fn enumCase(name: Str, tag: Int) -> EnumCase = { name = name, tag = tag }

fn enumInfoAdd(info: EnumInfo, c: EnumCase) -> EnumInfo = { cases = Cons(c, info.cases) }

fn enumCases(info: EnumInfo) -> List[EnumCase] = info.cases

fn _enMaxTag(xs: List[EnumCase], cur: Int) -> Int = match xs:
  Nil -> cur
  Cons(c, rest) -> do:
    let cur2 = match c.tag > cur:
      true -> c.tag
      false -> cur
    return _enMaxTag(rest, cur2)

fn enumNextTag(info: EnumInfo) -> Int = _enMaxTag(info.cases, -1) + 1

fn enumInfoAddAuto(info: EnumInfo, name: Str) -> EnumInfo = do:
  let tag = enumNextTag(info)
  return enumInfoAdd(info, enumCase(name, tag))

fn enumFindByName(info: EnumInfo, name: Str) -> Option[EnumCase] = match info.cases:
  Nil -> None
  Cons(c, rest) -> match c.name == name:
    true -> Some(c)
    false -> enumFindByName({ cases = rest }, name)

fn _enFromNames(names: List[Str], i: Int, acc: EnumInfo) -> EnumInfo = match names:
  Nil -> acc
  Cons(n, rest) -> _enFromNames(rest, i + 1, enumInfoAdd(acc, enumCase(n, i)))

fn enumInfoFromNames(names: List[Str]) -> EnumInfo = _enFromNames(names, 0, enumInfoEmpty())

fn enumFindByTag(info: EnumInfo, tag: Int) -> Option[EnumCase] = match info.cases:
  Nil -> None
  Cons(c, rest) -> match c.tag == tag:
    true -> Some(c)
    false -> enumFindByTag({ cases = rest }, tag)

fn enumTagByName(info: EnumInfo, name: Str) -> Option[Int] = match enumFindByName(info, name):
  None -> None
  Some(c) -> Some(c.tag)

fn enumNameByTag(info: EnumInfo, tag: Int) -> Option[Str] = match enumFindByTag(info, tag):
  None -> None
  Some(c) -> Some(c.name)

fn enumRequireByName(info: EnumInfo, name: Str) -> Result[EnumCase, Str] = match enumFindByName(info, name):
  None -> Err("unknown enum name")
  Some(c) -> Ok(c)

fn enumRequireByTag(info: EnumInfo, tag: Int) -> Result[EnumCase, Str] = match enumFindByTag(info, tag):
  None -> Err("unknown enum tag")
  Some(c) -> Ok(c)

fn enumHasName(info: EnumInfo, name: Str) -> Bool = isSome(enumFindByName(info, name))

fn enumHasTag(info: EnumInfo, tag: Int) -> Bool = isSome(enumFindByTag(info, tag))

fn enumInfoAddChecked(info: EnumInfo, c: EnumCase) -> Result[EnumInfo, Str] = match enumHasName(info, c.name) or enumHasTag(info, c.tag):
  true -> Err("duplicate enum case")
  false -> Ok(enumInfoAdd(info, c))

fn enumInfoAddAutoChecked(info: EnumInfo, name: Str) -> Result[EnumInfo, Str] = match enumHasName(info, name):
  true -> Err("duplicate enum name")
  false -> Ok(enumInfoAddAuto(info, name))

fn _enumValidateAcc(xs: List[EnumCase], seenNames: List[Str], seenTags: List[Int]) -> Result[Unit, Str] = match xs:
  Nil -> Ok(())
  Cons(c, rest) -> match c.tag < 0:
    true -> Err("negative enum tag")
    false -> match contains(seenNames, c.name):
      true -> Err("duplicate enum name")
      false -> match contains(seenTags, c.tag):
        true -> Err("duplicate enum tag")
        false -> _enumValidateAcc(rest, Cons(c.name, seenNames), Cons(c.tag, seenTags))

fn enumInfoValidate(info: EnumInfo) -> Result[Unit, Str] = _enumValidateAcc(info.cases, Nil, Nil)
