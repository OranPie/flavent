use _bridge_python
use collections.list
use collections.map
use std.result
use stringlib

type JsonValue = JNull | JBool(Bool) | JInt(Int) | JFloat(Float) | JStr(Str) | JArr(List[JsonValue]) | JObj(Map[Str, JsonValue])
type Json = JsonValue

fn jNull() -> JsonValue = JNull

fn _jLen(s: Str) -> Int = strLength(s)
fn _jCodeAt(s: Str, i: Int) -> Int = strCode(s, i)
fn _jSlice(s: Str, a: Int, b: Int) -> Str = strSliceRange(s, a, b)
fn _jChar(code: Int) -> Str = strFromCodePoint(code)

fn _jConcatPieces(xs: List[Str]) -> Str = match xs:
  Nil -> ""
  Cons(x, rest) -> x + _jConcatPieces(rest)

fn _jMod(x: Int, m: Int) -> Int = x - (x / m) * m

fn _jIntToStrPos(x: Int) -> Str = match x == 0:
  true -> "0"
  false -> _jIntToStrPosAcc(x, Nil)

fn _jIntToStrPosAcc(x: Int, acc: List[Str]) -> Str = match x <= 0:
  true -> _jConcatPieces(reverse(acc))
  false -> do:
    let d = _jMod(x, 10)
    let ch = _jChar(48 + d)
    return _jIntToStrPosAcc(x / 10, Cons(ch, acc))

fn _jIntToStr(x: Int) -> Str = match x < 0:
  true -> "-" + _jIntToStrPos(0 - x)
  false -> _jIntToStrPos(x)

fn _jFloatToStr(x: Float) -> Str = floatToStr(x)

fn _jEscChar(code: Int) -> Str = match code == 34:
  true -> "\\\""
  false -> match code == 92:
    true -> "\\\\"
    false -> match code == 10:
      true -> "\\n"
      false -> match code == 13:
        true -> "\\r"
        false -> match code == 9:
          true -> "\\t"
          false -> _jChar(code)

fn _jDumpStrAcc(s: Str, i: Int, pieces: List[Str]) -> List[Str] = match i >= _jLen(s):
  true -> pieces
  false -> do:
    let c = _jCodeAt(s, i)
    return _jDumpStrAcc(s, i + 1, Cons(_jEscChar(c), pieces))

fn _jDumpStr(s: Str) -> Str = do:
  let pieces = _jDumpStrAcc(s, 0, Nil)
  return "\"" + _jConcatPieces(reverse(pieces)) + "\""

fn _jJoinComma(xs: List[Str]) -> Str = match xs:
  Nil -> ""
  Cons(x, rest) -> match rest:
    Nil -> x
    Cons(_, _) -> x + "," + _jJoinComma(rest)

fn dumps(j: JsonValue) -> Str = match j:
  JNull -> "null"
  JBool(b) -> match b:
    true -> "true"
    false -> "false"
  JInt(n) -> _jIntToStr(n)
  JFloat(f) -> _jFloatToStr(f)
  JStr(s) -> _jDumpStr(s)
  JArr(xs) -> "[" + _jJoinComma(_jDumpArr(xs)) + "]"
  JObj(m) -> "{" + _jJoinComma(_jDumpObj(m)) + "}"

fn _jDumpArr(xs: List[JsonValue]) -> List[Str] = match xs:
  Nil -> Nil
  Cons(x, rest) -> Cons(dumps(x), _jDumpArr(rest))

fn _jDumpObj(m: Map[Str, JsonValue]) -> List[Str] = match m:
  Nil -> Nil
  Cons(e, rest) -> Cons(_jDumpStr(e.key) + ":" + dumps(e.value), _jDumpObj(rest))

type _JRes = { ok: Bool, i: Int, v: JsonValue }

type _JStrRes = { ok: Bool, i: Int, out: Str }

type _JIntRes = { ok: Bool, i: Int, out: Int }

type _JNumRes = { ok: Bool, i: Int, isFloat: Bool }

type _JURes = { ok: Bool, i: Int, code: Int }

fn _jSkipWs(s: Str, i: Int) -> Int = match i >= _jLen(s):
  true -> i
  false -> do:
    let c = _jCodeAt(s, i)
    return match c == 32 or c == 9 or c == 10 or c == 13:
      true -> _jSkipWs(s, i + 1)
      false -> i

fn _jStartsWith(s: Str, i: Int, lit: Str) -> Bool = do:
  let n = _jLen(lit)
  return match i + n > _jLen(s):
    true -> false
    false -> _jSlice(s, i, i + n) == lit

fn _jParseString(s: Str, i: Int) -> _JStrRes = do:
  let n = _jLen(s)
  return match i >= n or _jCodeAt(s, i) != 34:
    true -> { ok = false, i = i, out = "" }
    false -> _jParseStringAcc(s, i + 1, Nil)

fn _jParseStringAcc(s: Str, i: Int, pieces: List[Str]) -> _JStrRes = do:
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = false, i = i, out = "" }
    false -> do:
      let c = _jCodeAt(s, i)
      return match c == 34:
        true -> { ok = true, i = i + 1, out = _jConcatPieces(reverse(pieces)) }
        false -> match c == 92:
          true -> _jParseEscape(s, i + 1, pieces)
          false -> _jParseStringAcc(s, i + 1, Cons(_jChar(c), pieces))

fn _jParseEscape(s: Str, i: Int, pieces: List[Str]) -> _JStrRes = do:
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = false, i = i, out = "" }
    false -> do:
      let c = _jCodeAt(s, i)
      let ch = match c == 34:
        true -> "\""
        false -> match c == 92:
          true -> "\\"
          false -> match c == 47:
            true -> "/"
            false -> match c == 110:
              true -> "\n"
              false -> match c == 114:
                true -> "\r"
                false -> match c == 116:
                  true -> "\t"
                  false -> match c == 117:
                    true -> ""
                    false -> ""
      return match ch == "":
        true -> match c == 117:
          true -> do:
            let ur = _jParseUnicodeEscape(s, i + 1)
            return match ur.ok:
              true -> _jParseStringAcc(s, ur.i, Cons(_jChar(ur.code), pieces))
              false -> { ok = false, i = i, out = "" }
          false -> { ok = false, i = i, out = "" }
        false -> _jParseStringAcc(s, i + 1, Cons(ch, pieces))

fn _jHexVal(c: Int) -> Int = match c >= 48 and c <= 57:
  true -> c - 48
  false -> match c >= 65 and c <= 70:
    true -> 10 + (c - 65)
    false -> match c >= 97 and c <= 102:
      true -> 10 + (c - 97)
      false -> 0 - 1

fn _jParseUnicodeEscape(s: Str, i: Int) -> _JURes = do:
  let n = _jLen(s)
  return match i + 4 > n:
    true -> { ok = false, i = i, code = 0 }
    false -> do:
      let c0 = _jHexVal(_jCodeAt(s, i))
      let c1 = _jHexVal(_jCodeAt(s, i + 1))
      let c2 = _jHexVal(_jCodeAt(s, i + 2))
      let c3 = _jHexVal(_jCodeAt(s, i + 3))
      return match c0 < 0 or c1 < 0 or c2 < 0 or c3 < 0:
        true -> { ok = false, i = i, code = 0 }
        false -> do:
          let code = (((c0 * 16) + c1) * 16 + c2) * 16 + c3
          return { ok = true, i = i + 4, code = code }

fn _jIsDigit(c: Int) -> Bool = c >= 48 and c <= 57

fn _jParseDigits(s: Str, i: Int) -> Int = match i >= _jLen(s):
  true -> i
  false -> match _jIsDigit(_jCodeAt(s, i)):
    true -> _jParseDigits(s, i + 1)
    false -> i

fn _jParseInt(s: Str, i: Int) -> _JIntRes = do:
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = false, i = i, out = 0 }
    false -> do:
      let c = _jCodeAt(s, i)
      return match c == 45:
        true -> do:
          let r = _jParseUInt(s, i + 1, 0)
          return match r.ok:
            true -> { ok = true, i = r.i, out = 0 - r.out }
            false -> { ok = false, i = i, out = 0 }
        false -> do:
          let r = _jParseUInt(s, i, 0)
          return match r.ok:
            true -> { ok = true, i = r.i, out = r.out }
            false -> { ok = false, i = i, out = 0 }

fn _jParseUInt(s: Str, i: Int, acc: Int) -> _JIntRes = do:
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = false, i = i, out = acc }
    false -> do:
      let c = _jCodeAt(s, i)
      return match _jIsDigit(c):
        true -> _jParseUIntCont(s, i + 1, acc * 10 + (c - 48), true)
        false -> { ok = false, i = i, out = acc }

fn _jParseUIntCont(s: Str, i: Int, acc: Int, seen: Bool) -> _JIntRes = do:
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = seen, i = i, out = acc }
    false -> do:
      let c = _jCodeAt(s, i)
      return match _jIsDigit(c):
        true -> _jParseUIntCont(s, i + 1, acc * 10 + (c - 48), true)
        false -> { ok = seen, i = i, out = acc }

fn _jParseNumberSpan(s: Str, i0: Int) -> _JNumRes = do:
  let n = _jLen(s)
  let i1 = match i0 < n and _jCodeAt(s, i0) == 45:
    true -> i0 + 1
    false -> i0
  return match i1 >= n or not _jIsDigit(_jCodeAt(s, i1)):
    true -> { ok = false, i = i0, isFloat = false }
    false -> do:
      let i2 = _jParseDigits(s, i1)
      let hasDot = i2 < n and _jCodeAt(s, i2) == 46
      let i3 = match hasDot:
        true -> do:
          let i2b = i2 + 1
          match i2b >= n or not _jIsDigit(_jCodeAt(s, i2b)):
            true -> i0
            false -> _jParseDigits(s, i2b)
        false -> i2
      return match hasDot and i3 == i0:
        true -> { ok = false, i = i0, isFloat = false }
        false -> do:
          let cE = match i3 < n:
            true -> _jCodeAt(s, i3)
            false -> 0
          let hasExp = cE == 69 or cE == 101
          let i4 = match hasExp:
            true -> do:
              let j0 = i3 + 1
              let j1 = match j0 < n and (_jCodeAt(s, j0) == 43 or _jCodeAt(s, j0) == 45):
                true -> j0 + 1
                false -> j0
              match j1 >= n or not _jIsDigit(_jCodeAt(s, j1)):
                true -> i0
                false -> _jParseDigits(s, j1)
            false -> i3
          return match hasExp and i4 == i0:
            true -> { ok = false, i = i0, isFloat = false }
            false -> { ok = true, i = i4, isFloat = hasDot or hasExp }

fn _jParseValue(s: Str, i0: Int) -> _JRes = do:
  let i = _jSkipWs(s, i0)
  let n = _jLen(s)
  return match i >= n:
    true -> { ok = false, i = i, v = jNull() }
    false -> do:
      let c = _jCodeAt(s, i)
      return match c == 34:
        true -> do:
          let r = _jParseString(s, i)
          return match r.ok:
            true -> { ok = true, i = r.i, v = JStr(r.out) }
            false -> { ok = false, i = i, v = jNull() }
        false -> match c == 110 and _jStartsWith(s, i, "null"):
          true -> { ok = true, i = i + 4, v = jNull() }
          false -> match c == 116 and _jStartsWith(s, i, "true"):
            true -> { ok = true, i = i + 4, v = JBool(true) }
            false -> match c == 102 and _jStartsWith(s, i, "false"):
              true -> { ok = true, i = i + 5, v = JBool(false) }
              false -> match c == 91:
                true -> _jParseArray(s, i + 1)
                false -> match c == 123:
                  true -> _jParseObject(s, i + 1)
                  false -> do:
                    let nr = _jParseNumberSpan(s, i)
                    return match nr.ok:
                      false -> { ok = false, i = i, v = jNull() }
                      true -> do:
                        let seg = _jSlice(s, i, nr.i)
                        return match nr.isFloat:
                          true -> { ok = true, i = nr.i, v = JFloat(strToFloat(seg)) }
                          false -> do:
                            let ir = _jParseInt(s, i)
                            return match ir.ok and ir.i == nr.i:
                              true -> { ok = true, i = nr.i, v = JInt(ir.out) }
                              false -> { ok = false, i = i, v = jNull() }

fn _jParseArray(s: Str, i0: Int) -> _JRes = do:
  let i1 = _jSkipWs(s, i0)
  let n = _jLen(s)
  return match i1 < n and _jCodeAt(s, i1) == 93:
    true -> { ok = true, i = i1 + 1, v = JArr(Nil) }
    false -> _jParseArrayElems(s, i1, Nil)

fn _jParseArrayElems(s: Str, i0: Int, acc: List[JsonValue]) -> _JRes = do:
  let r = _jParseValue(s, i0)
  return match r.ok:
    false -> { ok = false, i = i0, v = jNull() }
    true -> do:
      let i1 = _jSkipWs(s, r.i)
      let n = _jLen(s)
      return match i1 < n and _jCodeAt(s, i1) == 44:
        true -> _jParseArrayElems(s, i1 + 1, Cons(r.v, acc))
        false -> match i1 < n and _jCodeAt(s, i1) == 93:
          true -> { ok = true, i = i1 + 1, v = JArr(reverse(Cons(r.v, acc))) }
          false -> { ok = false, i = i0, v = jNull() }

fn _jParseObject(s: Str, i0: Int) -> _JRes = do:
  let i1 = _jSkipWs(s, i0)
  let n = _jLen(s)
  return match i1 < n and _jCodeAt(s, i1) == 125:
    true -> { ok = true, i = i1 + 1, v = JObj(mapEmpty()) }
    false -> _jParseObjectPairs(s, i1, mapEmpty())

fn _jParseObjectPairs(s: Str, i0: Int, acc: Map[Str, JsonValue]) -> _JRes = do:
  let k0 = _jParseString(s, _jSkipWs(s, i0))
  return match k0.ok:
    false -> { ok = false, i = i0, v = jNull() }
    true -> do:
      let i1 = _jSkipWs(s, k0.i)
      let n = _jLen(s)
      return match i1 >= n or _jCodeAt(s, i1) != 58:
        true -> { ok = false, i = i0, v = jNull() }
        false -> do:
          let vr = _jParseValue(s, i1 + 1)
          return match vr.ok:
            false -> { ok = false, i = i0, v = jNull() }
            true -> do:
              let acc2 = mapPut(acc, k0.out, vr.v)
              let i2 = _jSkipWs(s, vr.i)
              return match i2 < n and _jCodeAt(s, i2) == 44:
                true -> _jParseObjectPairs(s, i2 + 1, acc2)
                false -> match i2 < n and _jCodeAt(s, i2) == 125:
                  true -> { ok = true, i = i2 + 1, v = JObj(acc2) }
                  false -> { ok = false, i = i0, v = jNull() }

fn loads(s: Str) -> Result[JsonValue, Str] = do:
  let r = _jParseValue(s, 0)
  let i2 = _jSkipWs(s, r.i)
  return match r.ok and i2 == _jLen(s):
    true -> Ok(r.v)
    false -> Err("json parse error")
